# linux-custom-syscalls
## Системные вызовы
В репозитории представлен исходный код системных вызовов, передающих копии структур ядра на строну пользователя.

- Системный вызов `cpu_itimer` возвращает пользователю одноименную структуру ядра заданного типа требуемого процесса.
- Системный вызов `pci_dev` возвращает пользователю структуру `pci_device_info` с частью информации содержащейся в стурктуре ядра `pci_dev` по заданным `vendor` и `device`.  

| rax | system call  | rdi | rsi | rdx      |
| --- | ------------ | --- | --- | -------- |
| 548 | cpu_itimer   | struct cpu_itimer *user_cpu_itimer | pid_t pid | unsigned int cpu_itimer_type |
| 549 | pci_dev_info | struct pci_dev_info *user_pci_device_info | unsigned int vendor | unsigned int device |

> Структуры, возвращаемые из уровня ядра, записываются по адресу переданному в `rdi`.

## Тестовые программы
Тестовые программы `test_cpu_itimer.c` и `test_pci_dev.c` тестируют работу системных вызовов `cpu_itimer` и `pci_dev` соответственно. Программы принимают на вход следующие аргументы командной строки:

```bash
    ./test_cpu_itimer <process_id> <itimer_type>
    ./test_pci_dev <vendor_id> <device_id>
```

Тестовые программы осуществляют вывод на экран полученных структур. Полученные результаты можно сравнить с информацией, которая была получена на уровне ядра и убедиться в корректности информации переданной на уровень пользователя при помощи команды `dmesg`.

## Инструкция по установке системных вызовов и сборке ядра
0. Скачать исходный код ядра требуемой версии с https://www.kernel.org/.
    > На момент написания системных вызовов было использовано ядро v6.0.6.
2. Поместить исходный код (каждый вызов в своей директории) в папку с исходниками ядра Linux.

2. Рядом с кодом системного вызова добавить Makefile со следующим содержанием:

    ```bash
    obj-y := <source_file_name>.o
    ```
    
    > В директориях репозитория уже содержатся готовые Makefile.

3. Найти вторую сверху строчку ```core-y``` в Makefile ядра. Дополнить ее названиями директорий с исходным кодом новых системных вызовов. Должно получиться:
    ```make
    core-y    := kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ cpu_itimer/ pci_dev/
    ```
    > В качестве разделителя обязательно использовать символ *пробела*.

4. Добавить в конец файла *(перед #endif)* ```include/linux/syscalls.h``` сигнатуры добавляемых системных вызовов и используемых структур:
    ```c
    asmlinkage long cpu_itimer(struct cpu_itimer *user_cpu_itimer, pid_t pid, unsigned int id);
    
    struct pci_dev_info;
    asmlinkage long pci_dev(struct pci_dev_info *user_pci_device_info, unsigned int vendor, unsigned int device);
    ```

5. Дополнить таблицу системных вызовов arch/x86/entry/syscalls/syscall_64.tbl, присвоив новым системным вызовам свободные номера:

    ```
    548    64    cpu_itimer    sys_cpu_itimer
    559    64    pci_dev       sys_pci_dev
    ```
    > В качестве разделителя использовать символ *табуляции*.

6. Собрать ядро (значение параметра -j варьируется в зависимости от количества ядер на машине):

   ```bash
   sudo make -j8
   sudo make modules_install -j8
   sudo make install -j8
   sudo update-grub
   ```
   > Количество логических ядер машины можно узнать при помощи команды `nproc`.
 
7. Перезагрузить систему. После этого новые вызовы должны быть доступны по номерам, указанным в 5 пункте.

