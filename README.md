# linux-custom-syscalls
## Системные вызовы
В репозитории представлен исходный код системных вызовов, передающих копии структур ядра на строну пользователя.

- Системный вызов `cpu_itimer` возвращает пользователю одноименную структуру ядра заданного типа требуемого процесса.
- Системный вызов `pci_dev` возвращает пользователю структуру `pci_device_info` с частью информации содержащейся в стурктуре ядра `pci_dev` по заданным `vendor` и `device`.  

| rax | system call  | rdi | rsi | rdx      |
| --- | ------------ | --- | --- | -------- |
| 548 | cpu_itimer   | struct cpu_itimer *user_cpu_itimer | pid_t pid | unsigned int cpu_itimer_type |
| 549 | pci_dev_info | struct pci_dev_info *user_pci_device_info | unsigned int vendor | unsigned int device |

> Структуры, возвращаемые из уровня ядра, записываются по адресу переданному в `rdi`.

## Тестовые программы
Тестовые программы `test_cpu_itimer.c` и `test_pci_dev.c` тестируют работу системных вызовов `cpu_itimer` и `pci_dev` соответственно. Программы принимают на вход следующие аргументы командной строки:

```bash
    ./test_cpu_itimer <process_id> <itimer_type>
    ./test_pci_dev <vendor_id> <device_id>
```

Тестовые программы осуществляют вывод на экран полученных структур. Полученные результаты можно сравнить с информацией, которая была получена на уровне ядра и убедиться в корректности информации переданной на уровень пользователя при помощи команды `dmesg`.

## Инструкция по установке системных вызовов и сборке ядра
0. Вытащить исходники текущего ядра либо скачать исходный код ядра требуемой версии с https://www.kernel.org/
    > На Ubuntu исходники текущего ядра можно получить при помощи команды `apt-get source linux-source`. Подробнее про другие способы описано [здесь](https://askubuntu.com/questions/159833/how-do-i-get-the-kernel-source-code).
    > Первый способ является предпочтительным, т.к. позволяет получить исходники ядра уже адаптированного под дистрибутив.

1. Поместить исходный код (каждый вызов в своей директории) в папку с исходниками ядра Linux.

2. Рядом с кодом системного вызова добавить Makefile со следующим содержанием:

    ```bash
    obj-y := <source_file_name>.o
    ```
    
    > В директориях репозитория уже содержатся готовые Makefile.

3. Найти вторую сверху строчку ```core-y``` в Makefile ядра. Дополнить ее названиями директорий с исходным кодом новых системных вызовов `cpu_itimer/` и `pci_dev/` . Должно получиться:
    ```make
    core-y    += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ cpu_itimer/ pci_dev/
    ```
    > В качестве разделителя обязательно использовать символ *пробела*.

4. Добавить в конец файла *(перед #endif)* ```include/linux/syscalls.h``` сигнатуры добавляемых системных вызовов и используемых структур:
    ```c
    asmlinkage long cpu_itimer(struct cpu_itimer *user_cpu_itimer, pid_t pid, unsigned int id);
    
    struct pci_dev_info;
    asmlinkage long pci_dev(struct pci_dev_info *user_pci_device_info, unsigned int vendor, unsigned int device);
    ```

5. Дополнить таблицу системных вызовов arch/x86/entry/syscalls/syscall_64.tbl, присвоив новым системным вызовам свободные номера:

    ```
    548    64    cpu_itimer    sys_cpu_itimer
    549    64    pci_dev       sys_pci_dev
    ```
   
6.  Подготовить файл конфигурации ядра:
    - config - традиционный способ конфигурирования. Программа выводит параметры конфигурации по одному, предлагая установить для каждого из них свое значение.
    - oldconfig - файл конфигурации создаётся автоматически, основываясь на текущей конфигурации ядра. Рекомендуется для начинающих.
    - defconfig - файл конфигурации создаётся автоматически, основываясь на значениях по-умолчанию для данной конкретной архитектуры.
    - menuconfig - псевдографический интерфейс ручной конфигурации, не требует последовательного ввода значений параметров. Рекомендуется для использования в терминале.
    - gconfig и xconfig - графические конфигураторы для ручной настройки.
    - localmodconfig и localyesconfig - автоматические конфигураторы. Конфиг создается на основе вызванных в данных момент модулей и запущенного ядра. Разница между этими двумя конфигураторами в количестве модулей. В первом случае их будет не менее 50% ядра, а во-втором не больше 2 модулей.

    > После вызова `make <config_type>` соответствующая программа конфигурации будет запущена.

7. Собрать ядро (значение параметра -j зависит от количества ядер на машине):

   ```bash
   sudo make -j8
   sudo make modules_install -j8
   sudo make install -j8
   sudo update-grub
   ```
   > Количество логических ядер машины можно узнать при помощи команды `nproc`.
 
8. Перезагрузить систему. После этого новые вызовы должны быть доступны по номерам, указанным в пункте 5.

